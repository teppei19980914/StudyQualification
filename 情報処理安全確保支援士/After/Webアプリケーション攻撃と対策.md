# Webアプリケーション攻撃と対策 ― XSS/CSRF/クリックジャッキング/セッション管理/MITB/HSTS/ダウングレード攻撃の体系的整理

## はじめに

2025年10月のプロジェクトマネージャ試験受験を終え、2026年秋の情報処理安全確保支援士に向けて勉強中です。
本記事を含めた各知識のインデックスや学習の道のりについては、「[情報処理安全確保支援士への道のり(随時更新中)](https://qiita.com/teppei19980914/items/6411cb70f2937cbefdcc)」をご参照ください。
**本記事は学習した内容を記載しています。**

## 該当問題

[情報セキュリティスペシャリスト平成21年秋期 午前Ⅱ 問7](https://www.sc-siken.com/kakomon/21_aki/am2_7.html)
[情報処理安全確保支援士平成29年春期 午前Ⅱ 問2](https://www.sc-siken.com/kakomon/29_haru/am2_2.html)
[情報処理安全確保支援士平成29年春期 午前Ⅱ 問5](https://www.sc-siken.com/kakomon/29_haru/am2_5.html)
[情報処理安全確保支援士平成30年春期 午前Ⅱ 問11](https://www.sc-siken.com/kakomon/30_haru/am2_11.html)
[情報処理安全確保支援士令和4年春期 午前Ⅱ 問11](https://www.sc-siken.com/kakomon/04_haru/am2_11.html)
[情報処理安全確保支援士令和4年春期 午前Ⅱ 問14](https://www.sc-siken.com/kakomon/04_haru/am2_14.html)
[情報処理安全確保支援士令和4年秋期 午前Ⅱ 問11](https://www.sc-siken.com/kakomon/04_aki/am2_11.html)
[情報処理安全確保支援士令和6年春期 午前Ⅱ 問1](https://www.sc-siken.com/kakomon/06_haru/am2_1.html)
[情報処理安全確保支援士令和6年春期 午前Ⅱ 問20](https://www.sc-siken.com/kakomon/06_haru/am2_20.html)

## クロスサイトスクリプティング(XSS)

### 定義

Webアプリケーションの入力値処理の不備を利用して、攻撃者が任意のスクリプトをWebページに埋め込み、利用者のブラウザ上で実行させる攻撃のことです。

### XSSが成立する本質的原因

XSSは 「Webサーバ側」ではなく「利用者のブラウザ側」でスクリプトが実行される ことが最大の特徴です。

#### 成立条件

* ユーザ入力を含むデータをHTMLに出力
* 出力時に 適切なエスケープ処理が行われていない
* ブラウザがそれを スクリプトとして解釈

### XSSの主な種類

#### 反射型XSS(Reflected XSS)

入力値がレスポンスに反映され、URLパラメータなどが攻撃点となります。

例：
```
https://example.com/search?q=<script>alert(1)</script>
```

##### 特徴

* メールやURLリンク経由で誘導
* 保存されない

#### 蓄積型XSS(Stored XSS)

悪意のあるスクリプトがDB等に保存され、多数の利用者に影響します。

例：掲示板/プロフィール欄/コメント欄等

##### 危険性

* 被害が継続/拡大しやすい
* 管理者権限奪取につながる可能性

#### DOM Based XSS

JavaScriptのDOM操作の不備であり、サーバを経由せずクライアント側のみで発生します。

##### 特徴

* サーバ側ログに残らない
* 検知が難しい

### XSSによって引き起こされる被害

#### 主な被害例

* セッションIDの窃取(セッションハイジャック)
* なりすまし操作
* フィッシング画面の表示
* マルウェア配布

試験で重要な観点：
```
XSSは 認証を破る攻撃ではなく、認証後の利用者を攻撃する
```

### XSSのセキュリティ対策

#### 出力時エスケープ

原則：
```
「入力時は信用しない」ではなく、「出力時に文脈に応じてエスケープする」ことが必要
```

例(HTML文脈)：

| 文字  | エスケープ    |
| --- | -------- |
| `<` | `&lt;`   |
| `>` | `&gt;`   |
| `"` | `&quot;` |
| `'` | `&#x27;` |
| `&` | `&amp;`  |

#### HTTPレスポンスヘッダによる対策

Content-Security-Policy(CSP)
```
Content-Security-Policy: script-src 'self'
```

* 外部/インラインスクリプトの実行制御
* XSS被害の抑止(完全防止ではない)

#### Cookieの保護(被害軽減)

| 属性       | 効果                     |
| -------- | ---------------------- |
| HttpOnly | JavaScriptからCookie取得不可 |
| Secure   | HTTPS通信時のみ送信           |
| SameSite | CSRF対策にも有効             |

**Cookie保護は XSS対策そのものではなく被害抑制です。**

#### 入力値検証

* 文字数制限
* 形式チェック(メール、数値など)

**入力チェックのみでは不十分です。**

### XSSと他攻撃との比較

| 攻撃           | 実行場所    | 主な目的    |
| ------------ | ------- | ------- |
| XSS          | 利用者ブラウザ | セッション窃取 |
| SQLインジェクション  | DB      | データ改ざん  |
| CSRF         | 利用者ブラウザ | 意図しない操作 |
| コマンドインジェクション | OS      | コマンド実行  |

### 関連知識

#### OWASP Top 10

* XSS は長年 Top10 常連
* 現在は「Injection」カテゴリに統合傾向

#### フレームワーク対策

* Thymeleaf/JSP/React 等は自動エスケープ機能あり
* 無効化すると脆弱性が復活

## クロスサイトリクエストフォージェリ(CSRF)

### 定義

CSRF は、**ユーザが意図しないリクエストを攻撃者が強制的に送信させる攻撃です。**

ポイント：

- 被害者は **正規ユーザとしてログイン済み**
- 攻撃者サイトを閲覧すると、被害者のブラウザが正規サイトへ勝手にリクエストを送る
- Cookie が自動送信されるため、**攻撃者は認証を突破できてしまう**

例：

- 不正送金
- 不正なメール送信
- 設定変更
- ユーザアカウントの削除

### CSRF の攻撃例(基本シナリオ)

**攻撃者はログイン情報を知らなくても操作を強制できます。**

1. ユーザが銀行サイトにログイン
2. ユーザが攻撃者の用意したページを閲覧
3. ページ内の hidden リクエスト(img タグなど)が銀行に対して「送金リクエスト」を発生
4. ユーザの Cookie が自動送信される
5. 銀行サイトは「本人の操作」と誤認し送金が成立

### CSRF が成立する条件(OWASP Root Cause)

OWASPによると、CSRF が成立する条件は以下の3つです。

1. **被害者がログイン状態(Cookie が有効)**
2. **攻撃者が任意のリクエストを被害者に送信させられる環境**
3. **リクエストにユーザ操作の正当性を確認する仕組みがない**

### CSRF の対策(必須)

#### CSRFトークン方式(最も推奨)

- サーバがランダム値トークンを発行
- フォームやリクエストに埋め込む
- 攻撃者はこのトークンを推測できない

#### SameSite Cookie 属性

Cookie に以下の属性を設定：

- `SameSite=Lax`(推奨)
- `SameSite=Strict`(最強)
- `SameSite=None; Secure`(クロスサイト利用が必要な場合)

SameSite は**クロスサイトのリクエストで Cookie を送らない**ように制御する仕組みで、モダンブラウザではデフォルトの防御です。

#### Referer/Origin チェック

正規サイトからのリクエストかを`Origin` または `Referer` ヘッダで確認します。

#### 二重送信クッキー(Double Submit Cookie)

CSRFトークンを Cookie とフォームの両方に付与し、一致を確認する方式です。

#### GET で状態変更を行わない(REST設計原則)

- GET = 参照のみ
- POST/PUT/DELETE = 状態変更

GET リクエストで設定変更できるシステムは脆弱です。

### CSRF と混同しやすい攻撃

#### XSS(クロスサイトスクリプティング)

- **スクリプトを注入してブラウザを乗っ取る攻撃**
- CSRF と異なり、攻撃者はユーザのブラウザ上で任意の JavaScript を実行できる
- XSS から CSRF トークンの盗難につながることがある

#### セッションフィクセーション

攻撃者が事前にセッションIDを与え、被害者の操作を乗っ取る攻撃です。
CSRFとは独立した攻撃だが、同時に狙われやすいです。

## クリックジャッキング攻撃(Clickjacking)

### 定義

クリックジャッキングとは、**ユーザが意図しない UI 操作をさせられる攻撃** であり、特に iframe を悪用した **UI Redressing(UI の見かけを偽装する攻撃)** の代表例です。

攻撃者は次の手法を使います。

- 正規サイトを透明(opacity:0)または半透明の iframe で表示
- ボタン/画像を重ね、ユーザのクリックを乗っ取る
- 表面的には無害に見えるが、実際には「設定変更」「購入」「許諾」ボタンを押してしまう

### 攻撃の典型パターン

#### iframe による透明化/重ね合わせ攻撃

```html
<iframe src="https://victim.example.com" style="opacity:0; z-index:1000; position:absolute;"></iframe>
<button style="z-index:999;">クリック！</button>
```

ユーザは上のボタンを押したつもりが、透明 iframe 内のボタンを押します。

#### SNS で多発：Likejacking

透明化した Facebook/Twitter の「Like」ボタンを押させます。

#### 権限許可の誤操作誘導(Permission Clickjacking)

スマートフォンやブラウザの許可画面を透明化し、下記などの「許可」ボタンを誤クリックさせます。

- カメラ
- マイク
- 位置情報
- 通知

### クリックジャッキングが危険な理由

クリックジャッキングでは、**攻撃者はユーザの認証済みセッションを悪用するだけでよく、Cookie を盗む必要はありません。**
そのため、下記などの利用者本人の操作として扱われてしまいます。

- アカウント設定変更
- OAuth の不正承認
- EC サイトでの商品購入
- 管理画面の設定操作

### 防御策(X-Frame-Options/CSP)

#### X-Frame-Options(旧来方式だが依然有効)

| 値 | 意味 |
|----|------|
| DENY | iframe での埋め込み禁止 |
| SAMEORIGIN | 同一オリジンのみ iframe を許可 |
| ALLOW-FROM URL | 指定 URL のみ許可(互換性は低い) |

例：

```
X-Frame-Options: SAMEORIGIN
```

#### CSP(Content-Security-Policy)frame-ancestors(現在の推奨)

**X-Frame-Options の後継的役割**を担い、柔軟かつブラウザ対応が広いです。

```
Content-Security-Policy: frame-ancestors 'self' https://trusted.example.com;
```

### アプリ側の追加対策

#### Frame Busting スクリプト(補助的)

ただし CSP 導入後は補助的な扱いです。

```javascript
if (top !== self) {
    top.location = self.location;
}
```

#### 重要操作の再認証

ユーザ操作 1 回で危険な処理を行えないようにします。

- 2FA(多要素認証)
- パスワード再入力
- 二段階確認ダイアログ

### 関連攻撃

| 攻撃名称 | 概要 |
|----------|------|
| **Likejacking** | SNS の「Like」を透明 iframe で押させる |
| **Cursorjacking** | カーソル位置を偽装して誤クリック誘導 |
| **Tabnabbing** | 放置されたタブを書き換えてフィッシング |
| **UI Deception** | UI の見た目を操作して錯誤誘発 |
| **CSRF** | クリックジャッキングと併用で強力に |

## Cookieとセッションハイジャック

### セッションIDとCookieの基本

HTTPはステートレスであるため、**ユーザ識別/ログイン状態保持**のために Web アプリケーションはセッションID(Session ID)を利用します。

典型例：

```
Set-Cookie: SESSIONID=abc123; Secure; HttpOnly; SameSite=Lax
```

### Cookieの主な属性

|属性|意味|
|---|---|
|Secure|HTTPSでのみ送信|
|HttpOnly|JavaScript 未参照化(XSS対策)|
|SameSite|CSRF対策(Lax/Strict/None)|
|Domain|送信先ドメイン制御|
|Path|送信先URLパス制御|
|Expires/Max-Age|有効期限|

### セッションハイジャック攻撃の種類

|攻撃名|概要|
|---|---|
|**セッションID盗聴**|HTTPSでないと平文盗聴される|
|**XSSによるCookie奪取**|document.cookie が盗まれる|
|**CSRF**|Cookieを悪用して本人として操作|
|**Session Fixation(セッション固定化)**|攻撃者が「特定のセッションID」を被害者に使わせる|

### Session Fixation(セッション固定化)攻撃

**攻撃者があらかじめ用意したセッションIDを、被害者に使わせてログインさせる攻撃** のことです。

#### 攻撃の流れ(RFC 6265/OWASP ASVS)

1. 攻撃者が Web サイトにアクセスし「未ログイン状態のセッションID」を取得
2. そのセッションIDを被害者に強制的に使わせる
   - URL パラメータ：`https://site/login?sessionid=AAA`
   - Set-Cookie ヘッダを偽装
   - 脆弱なサイトで攻撃者が Cookie を指定できるケース
3. 被害者がそのセッションIDでログインしてしまう
4. 攻撃者は同じセッションIDでログイン状態を再現できる(成り代わり成功)

#### 固定化攻撃が成立する条件

- **ログイン前後でセッションIDが変わらないこと**
- Cookie による正しい制御がされていないこと
- SameSite/HttpOnly/Secure が適切でない場合が多い

### Session Fixation 攻撃に有効な対策(必須)

#### ログイン時にセッションIDを再生成する(最重要)

OWASP ASVS/OWASP Session Management チートシートでは、**ログイン成功時に必ず新しいセッションIDへ再発行**が推奨されています。

```
login_success:
    regenerate_session_id()
```

これにより、攻撃者が用意した ID を使わせてもログイン時には無効化されます。

#### セッションIDを URL に含めない(URL-based Session)

URL パラメータにセッションIDがあると下記などに情報が残ってしまい、漏洩リスクが極めて高いため厳禁です。

- ブラウザ履歴
- リファラ
- ブックマーク
- Webサーバログ

#### Cookie の属性設定(Secure/HttpOnly/SameSite)

|属性|効果|
|---|---|
|Secure|HTTPSのみ送信 → 盗聴防止|
|HttpOnly|JSから参照不可 → XSSで盗まれない|
|SameSite=Lax/Strict|外部サイトから Cookie を送信させない|

Session Fixation 自体は Cookie 属性だけで完全には防げませんが、**攻撃者が Cookie を強制送信する可能性を下げる** 効果があります。

#### セッション有効期限の短縮

短いほど攻撃成功確率が下がります。

#### User-Agent/IP アドレスなどでセッション紐付け

100%ではないが、攻撃成功を大幅に困難にします。

### セッションID生成の要件(OWASP)

- **128bit以上の暗号学的乱数**
- **CSPRNG(暗号学的擬似乱数生成器)で生成**
- predictable(予測可能)でないこと

セッション固定化攻撃では「予測」ではなく「強要」が問題なので、**乱数の強度だけでは不十分** である点に注意が必要です。

### Cookie と Session Fixation の関係整理

|対策|Session Fixationに対する効果|補足|
|---|---|---|
|セッションID再生成|◎ 完全対策|必須|
|Secure|△|Cookie強制送信の難度が上がる|
|HttpOnly|×|Session Fixation は Cookie 読み取り不要|
|SameSite|○|外部からの強制送信を一部防ぐ|
|短期有効期限|△|攻撃成功ウィンドウが縮む|

**Session Fixation を根本的に封じられるのは「セッションID再生成」だけです。**

### CSRFとの違い

|項目|Session Fixation|CSRF|
|---|---|---|
|目的|攻撃者が用意したセッションIDを使わせる|ユーザのCookieを悪用して不正操作|
|前提|固定化した ID でログインさせる|正規のセッションIDを保持している|
|関連属性|SameSite が間接的効果|SameSite が主対策|

### XSSとの関係

* XSSは「セッションIDを盗む」
* Session Fixationは「セッションIDを押し付ける」

両者は**攻撃ベクトルが逆方向**です。

### OAuth2.0 のセッション固定化

OAuthの redirect_uri に State を含めない場合、「セッション固定化(State固定化)」が発生します。

## MITB(Man-in-the-Browser)攻撃とトランザクション署名

### 定義

MITB(Man-in-the-Browser)攻撃は、**ユーザの Web ブラウザ内部にマルウェアを侵入させ、通信内容や画面情報を攻撃者が改ざんする攻撃手法**です。
これは中間者攻撃(MITM)の発展形であり、**ブラウザ内部で起こるため、HTTPS(TLS)で通信を暗号化しても防止できません**。

### HTTPS では防げない攻撃

MITM は通信経路を盗聴しますが、MITB は下記などを攻撃者が自由に操作できます。
つまり、TLSによる暗号化は無意味になってしまいます。

- **通信の送信前**(ブラウザ内部)
- **画面表示の段階**
- **ユーザ入力情報**
- **送金金額/振込先書換え**

### MITBで何ができるか(代表例)

- オンラインバンキングの送金先口座番号を書き換える
- 送金金額をユーザの意図と異なる金額へ変更
- 偽画面を表示し、ユーザに誤操作を誘導
- OTP(ワンタイムパスワード)の奪取
- トランザクション結果画面を偽装

### MITB攻撃に使われる代表的マルウェア

| マルウェア | 特徴 |
|------------|-------|
| Zeus | ブラウザAPIフックの代表、バンキングマルウェアの象徴 |
| SpyEye | Zeus の亜種、フォーム書換え |
| Dyreza | TLSを迂回して認証情報を盗む |
| Gozi | 金融情報窃取、ブラウザ操作の改ざん |

これらは共通して「Webブラウザ内部で動作する」点が特徴です。

### MITB攻撃の流れ

1. PCがマルウェア感染
2. ブラウザ(IE/Chrome/Firefox)の API がフックされる
3. ユーザが正規サイトへログイン
4. 送金内容を入力
5. ブラウザ内部で攻撃者が**送信データを書き換え**
6. 改ざん済みデータがサーバに送信
7. 表示画面は偽装され、ユーザは異常に気付けない

### トランザクション署名(Transaction Signature)

#### 定義

**取引(トランザクション)内容そのものに電子署名を行い、改ざんを検知する方式です。**
送信内容が書き換えられた場合、**署名値が一致しなくなり攻撃を防止できます**。

#### 署名対象の例

これらをまとめてハッシュ化し、電子署名(RSA/ECDSA、またはHMAC)を生成します。

- 振込先口座番号
- 金額
- 取引日付
- 取引種別

#### トランザクション署名の流れ

トランザクション署名によって、ブラウザが乗っ取られても攻撃者は正しい署名値を作れません。

1. 取引内容(例：振込先/金額)をユーザが外部デバイス(トークン)へ入力
2. トークンが内容をハッシュ化し署名値を生成
3. 生成された署名値をユーザがシステムに入力
4. サーバ側が取引内容と署名値を照合
5. 改ざんがあれば署名検証が失敗し取引拒否

#### トランザクション署名が MITB に強い理由

MITB が成立するには、攻撃者が改ざんした送金内容が「正当なもの」としてサーバに受理される必要があります。
しかし、トランザクション署名では、下記のデータが一致しないため検証に失敗することになります。

1. 利用者が認証デバイスに入力した内容
2. 攻撃者がブラウザ内部で改ざんした内容

### MITB対策の周辺技術(補完的技術)

#### 多要素認証(MFA)

- パスワード + OTP
- 生体認証(FIDO2/WebAuthn)

ただし MITB(ログイン後の改ざん)には不十分です。

#### セキュアブラウザ

- 通常ブラウザと分離
- 改ざん検知機能
- 金融機関専用アプリなどで採用

#### デバイス証明書

- 正当な端末からのみアクセスを許可
- 攻撃者の環境からの不正アクセスを排除

#### 不正送金対策(銀行業界の実装例)

- 送金内容の確認通知(SMS/Push)
- 振込先チェック(過去取引との乖離検出)
- 行動分析(AI 不正検知)

### MITM と MITB の比較(試験頻出)

| 項目 | MITM | MITB |
|------|------|------|
| 攻撃位置 | ネットワーク経路 | ブラウザ内部 |
| HTTPS の有効性 | 有効 | 無効 |
| 攻撃影響 | 盗聴/改ざん可能 | 入力/表示/送信内容の全支配 |
| 対策 | TLS/証明書ピンニング | トランザクション署名、セキュアブラウザ |

## HTTP Strict Transport Security(HSTS)とHTTPレスポンスヘッダー

### 定義(RFC 6797)

**HSTS(HTTP Strict Transport Security)** とは、Webサーバが HTTPレスポンスヘッダーを通じてブラウザに対し、「このサイトには **今後、必ず HTTPS でのみ接続せよ**」と指示するセキュリティ機構です。

- 標準：**RFC 6797**
- 目的：
    - 平文HTTP通信の防止
    - SSL Stripping 攻撃の防止
    - HTTPS強制による通信の完全性/機密性確保

### HSTS の仕組み(動作原理)

#### 基本フロー

1. ユーザが **HTTPS** でサイトにアクセス
2. サーバが HTTPS 応答時に **Strict-Transport-Security ヘッダー** を返却
3. ブラウザがその内容を **ローカルに記憶**
4. 指定期間中、**HTTPアクセスを自動的に HTTPS に置き換え**

重要点：
- **HTTP通信そのものを行わずに HTTPS に変換**する
- サーバに届く前に、**ブラウザ内部で処理される**

### Strict-Transport-Security ヘッダーの構造

#### 基本構文(RFC 6797)

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

#### 各ディレクティブの意味

| ディレクティブ | 意味 |
|----------------|------|
| max-age | HSTSを有効とする秒数(例：31536000秒＝1年) |
| includeSubDomains | サブドメインにもHSTSを適用 |
| preload | ブラウザのHSTSプリロードリスト登録を許可 |

### HSTS と HTTPSリダイレクトの違い

| 観点 | HTTPSリダイレクト | HSTS |
|------|------------------|------|
| 処理主体 | サーバ | **ブラウザ** |
| 初回HTTP通信 | 発生する | **発生しない(記憶後)** |
| SSL Stripping耐性 | 弱い | **強い** |
| 依存要素 | HTTPレスポンス | HTTPSレスポンス＋記憶 |

**HSTSは「リダイレクトの上位互換」ではなく、「攻撃耐性を補強する仕組み」です。**

### SSL Stripping 攻撃と HSTS

#### SSL Stripping 攻撃とは

- 攻撃者が **HTTP→HTTPS のリダイレクトを改ざん**
- ユーザを **平文HTTP通信のまま** 偽装サイトへ誘導
- 認証情報を盗聴/改ざん

#### HSTS の防御効果

- ブラウザが **最初からHTTPSしか使わない**
- 攻撃者が HTTP通信を成立させられない
- よって **SSL Stripping が成立しない**

### HSTS の注意点/運用リスク

#### 設定ミスの影響

- HTTPSが利用不能になると **サイトに一切アクセスできなくなる**
- 証明書失効/期限切れ時の影響が大きい

#### 初回アクセス問題

- 初回が HTTP の場合、HSTS がまだ効かない
- **HSTS Preload** により対策

### HSTS Preload

#### 概要

- Chrome/Firefox/Edge 等が持つ **事前登録リスト**
- 初回アクセス前から HTTPS を強制

#### 利用条件(代表例)

- max-age >= 31536000
- includeSubDomains 指定
- HTTPS完全対応

### HTTPレスポンスヘッダーの位置づけ

#### HTTPレスポンスヘッダーとは

サーバがクライアントに返す **制御情報** を含むヘッダー群のことです。

例：
- Cache-Control
- Expires
- Set-Cookie
- Content-Type
- Strict-Transport-Security

#### セキュリティヘッダーの役割

- **アプリ改修不要でブラウザ挙動を制御**
- Web攻撃(XSS/Clickjacking/MITM)の防止

### 関連セキュリティヘッダー

| ヘッダー | 防御対象 |
|---------|----------|
| CSP | XSS |
| X-Frame-Options | Clickjacking |
| X-Content-Type-Options | MIMEスニッフィング |
| Referrer-Policy | 情報漏えい |

## Cache-Control ヘッダー

### 定義(RFC 9111/RFC 7234)

**Cache-Control** は、HTTP通信において「レスポンスをキャッシュしてよいか、どの程度保持してよいか」を指定するための **キャッシュ制御用HTTPヘッダー** です。

- 標準：**RFC 9111(旧 RFC 7234)**
- 対象：
  - ブラウザキャッシュ
  - プロキシキャッシュ
  - CDN

### Cache-Control の基本構文

```
Cache-Control: <directive>, <directive>, ...
```

複数のディレクティブをカンマ区切りで指定します。

例：
```
Cache-Control: no-store, no-cache, must-revalidate
```

### 代表的な Cache-Control ディレクティブ

#### キャッシュ禁止系

##### no-store

- **一切キャッシュしてはならない**
- ディスク/メモリ保存も禁止

用途：
- 認証情報
- 個人情報
- 金融取引画面

##### no-cache

- キャッシュ保存は可能
- **再利用時に必ずサーバへ再検証**

#### 有効期限系

##### max-age

- キャッシュの有効期間(秒)
- 指定期間は再問い合わせ不要

##### s-maxage

- **共有キャッシュ(プロキシ/CDN)専用**
- max-age より優先される

#### 再検証系

##### must-revalidate

- 有効期限切れ後は **必ず再検証**
- 独自判断での再利用を禁止

#### キャッシュ範囲指定

##### public

- 誰でもキャッシュ可能
- 認証不要な静的コンテンツ向け

##### private

- **共有キャッシュは禁止**
- ブラウザ個人キャッシュのみ許可

### なぜキャッシュ制御が重要か

キャッシュが原因で以下のリスクが生じます。

- ログアウト後も履歴から閲覧可能
- 他人の端末で個人情報が残留
- プロキシに機密情報が保存される

### 安全な設定例(認証画面)

**「no-store」が最重要です。**

```
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
```

### Expires/Pragma との関係

| ヘッダー | 特徴 |
|--------|------|
| Cache-Control | 現行標準、詳細制御可能 |
| Expires | 絶対時刻指定、古い仕様 |
| Pragma | HTTP/1.0互換用 |

### TLSとの関係

- HSTSは **TLSそのものを提供しない**
- あくまで **HTTPS利用を強制する制御策**

### キャッシュと Cookie

- Set-Cookie があるレスポンスは private 扱いされやすい
- 認証情報とキャッシュの組み合わせは要注意

### CDN と Cache-Control

- s-maxage が CDN 制御で重要
- private 指定で CDN キャッシュ回避

## SSL/TLSのダウングレード攻撃(Downgrade Attack)

### 定義

**SSL/TLSのダウングレード攻撃**とは、クライアントとサーバ間のTLS通信において、攻撃者が通信を妨害/改変することで、本来使用可能な新しいTLSバージョンや強力な暗号方式ではなく、脆弱な旧バージョン/弱い暗号方式を強制的に使用させる攻撃です。

### SSL/TLSの前提知識

#### バージョンネゴシエーションの仕組み

TLS通信は、以下の流れで開始されます。

1. **ClientHello**
   - クライアントが対応可能なTLSバージョン一覧を提示
   - 利用可能な暗号スイートを提示
2. **ServerHello**
   - サーバが採用するTLSバージョンと暗号方式を選択

**双方が対応している中で、最も高い共通レベルが選ばれます。**

#### 下位互換性という設計思想

- 古いクライアントでも接続できるように
- SSL 3.0/TLS 1.0/TLS 1.1 を残している環境が多かった

この「互換性」が攻撃の起点になります。

### ダウングレード攻撃の基本原理

#### 攻撃の本質

攻撃者は、下記の点が重要です。

- 通信内容を解読する必要はない
- **ハンドシェイクを妨害/失敗させるだけでよい**

#### 典型的な攻撃シナリオ

1. クライアントが TLS 1.2/1.3 を提案
2. 攻撃者が通信を妨害(パケット破棄/改変)
3. 接続失敗と誤認させる
4. クライアントが **古いTLS/SSLで再接続**
5. サーバがそれを受け入れる
6. **弱い暗号通信が成立**

### なぜ危険なのか

**攻撃者が「脆弱性を新たに作る」のではなく、すでに存在する脆弱な仕様を"使わせる"点にあります。**

#### 利用される代表的な脆弱プロトコル

| プロトコル | 問題点 |
|---|---|
| SSL 2.0 | 設計的に破綻(使用禁止) |
| SSL 3.0 | POODLE 攻撃 |
| TLS 1.0 | BEAST 攻撃 |
| 弱い暗号 | RC4, EXPORT 暗号 |

### 代表的なダウングレード攻撃の実例

#### POODLE攻撃(SSL 3.0)

- SSL 3.0 のパディング処理の欠陥を悪用
- ダウングレードにより SSL 3.0 を使わせる
- Cookie 情報などが漏洩

#### FREAK攻撃(EXPORT暗号)

- 米国の旧輸出規制向け弱暗号を利用
- 鍵長が極端に短く、現実的に解読可能

#### Logjam攻撃

- 弱い Diffie-Hellman パラメータを強制
- 中間者攻撃が可能

### 主な対策(頻出)

#### 古いプロトコルの無効化

- SSL 2.0/3.0 を完全に無効
- TLS 1.0/1.1 も非推奨

#### TLS_FALLBACK_SCSV(RFC 7507)

- 不正なダウングレードを検知する仕組み
- 意図しない再接続を拒否

#### 強力な暗号スイートのみ許可

- EXPORT暗号の禁止
- RC4の禁止
- 安全なAEAD暗号(AES-GCMなど)を使用

#### HSTS(HTTP Strict Transport Security)

- HTTPS 強制
- プロトコルダウングレードの抑止

### 中間者攻撃(MITM)との関係

ダウングレード攻撃は、下記のとおりです。

- **MITM攻撃の一種**
- ただし「盗聴」よりも「弱体化」が目的

### TLS 1.3 での改善点

TLS 1.3 では：

- 古い暗号/プロトコルを完全排除
- ハンドシェイクが簡素化
- ダウングレード耐性が強化
