# アジャイル開発・オブジェクト指向・デザインパターン・UMLの体系整理

## はじめに

2025年10月のプロジェクトマネージャ試験受験を終え、2026年春の情報処理安全確保支援士に向けて勉強中です。
本記事を含めた各知識のインデックスや学習の道のりについては、「[情報処理安全確保支援士への道のり(随時更新中)](https://qiita.com/teppei19980914/items/6411cb70f2937cbefdcc)」をご参照ください。
**本記事は学習した内容を記載しています。**

## 該当問題

[情報セキュリティスペシャリスト平成22年春期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/22_haru/am2_22.html)
[情報セキュリティスペシャリスト平成24年秋期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/24_aki/am2_22.html)
[情報セキュリティスペシャリスト平成28年春期 午前Ⅱ 問23](https://www.sc-siken.com/kakomon/28_haru/am2_23.html)
[情報処理安全確保支援士平成30年春期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/30_haru/am2_22.html)
[情報処理安全確保支援士令和5年秋期 午前Ⅱ 問23](https://www.sc-siken.com/kakomon/05_aki/am2_23.html)
[情報処理安全確保支援士令和6年秋期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/06_aki/am2_22.html)

## アジャイルソフトウェア開発とは

アジャイル(Agile)とは、**変化に適応しながら、反復的/漸進的に価値を提供するソフトウェア開発手法**です。

根拠：

- **アジャイルソフトウェア開発宣言(2001)**
  https://agilemanifesto.org/iso/ja/manifesto.html
- Scrum Guide(公式)
- IPA『アジャイル開発の教科書』

### アジャイルの価値観(Agile Manifesto)

アジャイルでは次の4つを重視します。

1. **プロセスやツールよりも個人と対話を**
2. **包括的な文書よりも動くソフトウェアを**
3. **契約交渉よりも顧客との協調を**
4. **計画に従うよりも変化への対応を**

## アジャイル開発の特徴

| 特徴 | 説明 |
|------|------|
| 反復/短サイクル開発 | 小さく作り、小さく改善する(Iteration/Sprint) |
| 顧客との継続的な協働 | プロダクトオーナーが価値を最大化 |
| 継続的インテグレーション | ビルド/テストを自動化 |
| 要求の変化に強い | 計画より適応を重視 |
| チーム主体性 | 自律的チームによる改善 |

### XP(Extreme Programming)

- 技術プラクティスを重視
- ペアプログラミング、テスト駆動開発(TDD)、CI などが代表

## ペアプログラミング(XPの中核プラクティス)

### ペアプログラミングとは

ペアプログラミング(Pair Programming)とは、**2人1組で 1 台のコンピュータを使い、協力してプログラミングを行う手法**です。

根拠：

- Kent Beck "Extreme Programming Explained"
- XP 公式プラクティスとして定義

### 役割分担

ペアプログラミングには 2 つの役割があります。
一定時間ごとに交代することで品質と理解が向上します。

| 役割 | 説明 |
|------|------|
| **ドライバ(Driver)** | キーボードを操作しコードを書く |
| **ナビゲータ(Navigator)** | レビュー/設計/方針確認など全体的視点で支援 |

### ペアプログラミングのメリット

#### 品質向上

- コードをリアルタイムでレビュー
- バグの早期発見が可能

#### 知識共有(ナレッジシェア)

- 新人育成に有効
- チームの属人化防止

#### 設計改善

- 2 人の視点でアーキテクチャを見直すため設計品質が安定

#### コミュニケーション改善

- チームワークの向上
- 仕様理解のズレ減少

### デメリット

- 工数が増えるように見える
- チームスキルが均一でない場合は効果が低下
- 性格的相性の問題が発生することもある

## アジャイル開発とセキュリティ

SC試験で問われるポイントとして、**アジャイル＝セキュリティが弱い という誤解**への対処があります。
アジャイルでは次のようにセキュリティを内包できます。

- セキュリティ要求を「ユーザストーリー」として管理
- スプリントごとに脆弱性テストを実施
- DevSecOps によりビルド時に自動スキャン
- レビューやペアプロでコード品質が向上

## スクラム(Scrum)とは

Scrum Guide(2020版)で定義されるフレームワークであり、**複雑性(Complexity)の高い課題を反復的/漸進的に解決する開発方法**です。
下記を核として構成されます。

- 明確な役割(3つ)
- 定義されたイベント(5つ)
- 透明性を担保する作成物(3つ)

## スクラムチームと3つの役割

### プロダクトオーナー(Product Owner)

役割：**価値の最大化を担う役割**

#### 主な責任

- プロダクトバックログの作成と優先順位付け
- ステークホルダとの調整
- プロダクト価値の最大化
- プロダクトゴールを策定し明示的に伝えること

#### 特徴

- 1 スプリント内で何を作るか(What)を決める権限を持つ
- 開発チームに「どう作るか(How)」は指示しない

### スクラムマスター(Scrum Master)

役割：**スクラムの理解と実践を促す促進者(ファシリテータ)**

#### 主な責任

- スクラムのルール/価値基準の徹底
- 障害除去(インピーディメント管理)
- チームの自己管理/自律性の支援
- 組織へのスクラム導入支援

#### 特徴

- プロジェクト管理者ではない
- 権限ではなく、コーチングやファシリテーションによる支援が中心

### 開発チーム(Developers)

役割：**実際にプロダクトを作り上げる自律的チーム**

#### 主な責任

- スプリントバックログの作成
- 実装/テスト/ドキュメントなど必要な全作業の遂行
- インクリメントの完成(DoD 準拠)

#### 特徴

- クロスファンクショナル(多能工)
- 自己組織化(Self-Organizing)
- チーム外から指示されない

## スクラムの5つのイベント(Scrum Events)

Scrum Guide で定義される **強制イベント** は以下の5つです。

### スプリント(Sprint)

スクラムの基盤となる反復期間(1～4週間)でスプリント中断は原則禁止されます。

### スプリントプランニング(Sprint Planning)

**「このスプリントで何を作るか」「どのように作るか」を決める会議**のことです。

主要アウトプット：

- スプリントゴール
- スプリントバックログ

### デイリースクラム(Daily Scrum)

毎日15分以内のチームの同期会議のことです。

典型的な確認内容：

- 昨日行ったこと
- 今日行うこと
- 課題/障害の共有

### スプリントレビュー(Sprint Review)

スプリント成果物(インクリメント)をステークホルダに共有し、フィードバックを得るイベントです。

### スプリントレトロスペクティブ(Sprint Retrospective)

チームの**プロセス改善**を議論する振り返りイベントです。

## スクラムの3つの作成物(Artifacts)

### プロダクトバックログ(Product Backlog)

- プロダクトに必要な要求、改善、機能をリスト化したもの
- PO が優先度を管理
- 常に進化し続ける

### スプリントバックログ(Sprint Backlog)

- プロダクトバックログの中からスプリントで実施する項目の集合
- 開発チームが **「どう実施するか」** を細分化し管理する

### インクリメント(Increment)

- スプリントで作られた完成済み成果物
- 「完成の定義(Definition of Done)」を満たす必要がある

## アジャイルとスクラムの違い(整理)

|項目|アジャイル|スクラム|
|---|---|---|
|種別|価値観/思想|具体的フレームワーク|
|文書|アジャイル宣言|Scrum Guide|
|構成要素|原則/価値観|役割/イベント/作成物|
|適用範囲|開発全般|複雑性の高い開発|

## アジャイル周辺知識(SC試験頻出)

### バーンダウンチャート

スプリント残作業量の可視化に利用します。

### ユーザストーリー

要求を簡潔に示す形式です。

> As a(ユーザ)
> I want(機能)
> So that(価値)

### TDD(テスト駆動開発)

テストを書いてからコードを書く XP の中心手法です。

### CI/CD(継続的インテグレーション/デリバリ)

自動ビルド/テスト/デプロイにより価値提供を継続します。

### DevOps/DevSecOps

開発と運用の壁をなくし、セキュリティも統合する考え方です。

## 汎化(Generalization)

### 定義

複数のクラスが共通して持つ属性や操作を抽出し、**より上位の抽象クラス(スーパークラス)としてまとめること**です。

### エビデンス

UML2.0(OMG Unified Modeling Language 2.x 仕様書)で Generalization は「ある分類子が別の分類子の特殊化であることを示す関係」と定義されています。

### 目的

- 重複コード/重複概念の排除
- モデルの簡潔化
- 共通機能の一元管理

### 例

```
動物
 ├─ 犬
 └─ 猫
```
犬/猫に共通する「呼吸する」「歩く」などを「動物」にまとめます。

## 特化(Specialization)

### 定義

汎化の逆に、**上位概念(スーパークラス)をより具体的な下位概念(サブクラス)に分ける操作**です。

### 目的

- 振る舞いの差異を明確化
- 特定属性/操作の追加

### 例

```
従業員
 ├─ 正社員(給与形態：月給)
 └─ アルバイト(給与形態：時給)
```

## 継承(Inheritance)

### 定義

サブクラスがスーパークラスの **属性/メソッドを受け継ぐ** 機能です。

### エビデンス

オブジェクト指向言語(Java, C++, Python 等)でも共通して「コード再利用」「多様性(ポリモーフィズム)の基盤」とされます。

### 特徴

- **IS-A関係**(〜は〜の一種)を表す
- サブクラスはスーパークラスの振る舞いを拡張/上書きできる(オーバーライド)

## サブクラス(Subclass)

### 定義

スーパークラスを継承し、より具体的な属性/振る舞いを持つクラスです。

### ポイント

- スーパークラスの性質＋独自機能を持つ
- Liskov Substitution Principle(LSP)を満たす必要がある
    → サブクラスはスーパークラスとして置き換えても問題なく振る舞うべき

## 汎化/特化/継承の違い(試験で問われるポイント)

| 概念 | 方向性 | モデリング上の役割 |
|------|--------|----------------------|
| 汎化 | 下位 → 上位 | 共通性の抽出、抽象化 |
| 特化 | 上位 → 下位 | 具体化、差異の明確化 |
| 継承 | 設計/実装 | 属性/メソッドの引継ぎ |

## 情報隠蔽との関係

### 情報隠蔽(Information Hiding)

- クラス内部のデータ構造/実装を外部から隠すこと
- 外部に公開するのは **必要なインタフェースのみ**

### 継承と情報隠蔽の注意点

継承を使うと、スーパークラスの内部構造に依存した実装になりがちです。
そのため **継承より合成(Composition over Inheritance)** が推奨される場合も多いです。

## スーパークラス設計時の注意点

- 不必要に抽象クラスを増やすと複雑化する
- 共通化は「本当に共通の性質」に限定
- 多重継承は言語によっては問題を生む(C++ は可、Java は不可)

## SOLID 原則(高度試験頻出)

- **S**：単一責任原則
- **O**：開放閉鎖原則(変更に閉じ、拡張に開く)
- **L**：リスコフの置換原則
- **I**：インターフェース分離原則
- **D**：依存性逆転原則

→ いずれも **情報隠蔽/疎結合** の思想に基づきます。

## オブジェクト指向のメリット

- 再利用性
- 保守性
- 拡張性
- モジュール化

## 関数型や手続き型との比較

| 手法 | 特徴 |
|------|------|
| 手続き型 | 処理手順が中心、データと処理が分離 |
| 関数型 | 副作用排除、状態変更を嫌う |
| オブジェクト指向 | データ中心、責務分担が明確 |

## ソフトウェアパターンとは

### 定義(エビデンス)

- Christopher Alexander
- Gamma et al., *Design Patterns: Elements of Reusable Object-Oriented Software*
- POSA(Pattern-Oriented Software Architecture)

**ソフトウェアパターンとは、繰り返し発生する設計上の問題に対して、実績のある解決策を再利用可能な形でまとめた知識体系です。**

重要なのは「**コード断片**」ではなく、下記をセットで表現する点です。

- 問題(Context)
- 解決すべき課題(Problem)
- 解決方法(Solution)
- 効果/トレードオフ(Consequences)

## ソフトウェアパターンの階層分類(試験重要)

ソフトウェアパターンは、適用レベルにより次のように分類されます。

### アーキテクチャパターン

#### 特徴

- システム全体構造を規定
- 高レベル設計

#### 代表例

- MVC(Model–View–Controller)
- レイヤードアーキテクチャ
- クライアント／サーバ
- マイクロサービス

→ **「システムの骨格」を決めます**

### デザインパターン(GoF)

#### 特徴

- クラス/オブジェクト間の設計指針
- オブジェクト指向設計の再利用知識

### イディオム(実装パターン)

#### 特徴

- 特定言語に依存
- コーディングレベル

#### 例

- Java の try-with-resources
- C++ の RAII

## GoF(Gang of Four)とは

### GoF の位置付け(エビデンス)

- Erich Gamma
- Richard Helm
- Ralph Johnson
- John Vlissides

1994年に以下の名著を出版し、この書籍で **23個のデザインパターン** が体系化されました。
***Design Patterns: Elements of Reusable Object-Oriented Software***

## GoF デザインパターンの全体構成

GoF のデザインパターンは、目的別に **3分類** されます。

```
GoF デザインパターン(全23)
├─ 生成(Creational) : 5
├─ 構造(Structural) : 7
└─ 振る舞い(Behavioral) : 11
```

## 生成パターン(Creational Patterns)

### 目的

- **オブジェクト生成方法を抽象化**
- new の乱用を防止

### 代表例

| パターン | 概要 |
|---|---|
| Singleton | インスタンスを1つに制限 |
| Factory Method | 生成処理をサブクラスに委譲 |
| Abstract Factory | 関連オブジェクト群を生成 |
| Builder | 構築手順と表現を分離 |
| Prototype | 複製による生成 |

## 構造パターン(Structural Patterns)

### 目的

- **クラスやオブジェクトの構造を柔軟に構成**
- 変更に強い設計

### 代表例

| パターン | 概要 |
|---|---|
| Adapter | インタフェース変換 |
| Decorator | 機能を動的に追加 |
| Composite | 木構造を一様に扱う |
| Facade | 窓口を単純化 |
| Proxy | 代理制御 |

## 振る舞いパターン(Behavioral Patterns)

### 目的

- **オブジェクト間の責務分担と通信制御**

### 代表例

| パターン | 概要 |
|---|---|
| Observer | 状態変化の通知 |
| Strategy | アルゴリズム切替 |
| Command | 処理をオブジェクト化 |
| Template Method | 処理骨格を定義 |
| State | 状態に応じて振る舞い変更 |

## ソフトウェアパターンとフレームワークの違い

| 項目 | パターン | フレームワーク |
|---|---|---|
| 形態 | 抽象的知識 | 具体的コード |
| 再利用 | 思想/設計 | 実装 |
| 例 | MVC, GoF | Spring, Struts |

## アーキテクチャパターンとの関係

- MVC は **アーキテクチャパターン**
- MVC 内部実装で GoF が使われる

例：
- Observer(View更新)
- Strategy(入力処理切替)

## アンチパターン

### 定義

- 一見よさそうだが、実際には問題を悪化させる設計

### 例

- God Object
- Spaghetti Code
- Golden Hammer

## UML 2.x の概要

UML(Unified Modeling Language)は、OMG(Object Management Group)が標準化している**システム/ソフトウェアの構造と振る舞いを可視化するためのモデリング言語**です。

UML 2.x では、ダイアグラムは大きく以下に分類されます。

- **構造図(Structure Diagrams)**：静的な構造／クラス／コンポーネント／配置など
- **振る舞い図(Behavior Diagrams)**：動作やオブジェクト間のやり取り(相互作用)など

試験的には、以下を分類できることが重要です。

- 「どの図が"構造"を表すのか」
- 「どの図が"振る舞い／相互作用"を表すのか」

## アクティビティ図(Activity Diagram)

### 定義と目的

アクティビティ図は、**アクション(処理)の実行順序や分岐/並行/結合などを表現する図**です。ビジネスプロセスやワークフロー、アルゴリズム手順などをモデル化するのに適しています。

### 主な要素

- **アクション(Action)**：アクティビティ内の最小の実行単位
- **開始ノード／終了ノード**：ワークフローの開始/終了を表す
- **制御フロー／オブジェクトフロー**：制御の流れ／データの流れを矢印で表現
- **分岐(Decision)/マージ(Merge)**：条件による分岐／条件の合流
- **フォーク(Fork)/ジョイン(Join)**：並列実行の開始／同期

### 活用イメージ(支援士的観点)

- 認証プロセス(ID/パスワード入力 → 認証サーバ照会 → 成功／失敗)
- インシデント対応フロー
- 承認ワークフロー(申請 → 承認 → 払出 等)

## コミュニケーション図(Communication Diagram)

### 定義と目的

コミュニケーション図(UML 1.x ではコラボレーション図)は、**オブジェクト(または役割)間の関係と、その間でやり取りされるメッセージの流れを表現する相互作用図**です。

### 主な要素

- **ライフライン(Lifeline)**：オブジェクトやクラスのインスタンス
- **リンク(Association/Connector)**：オブジェクト間の関連
- **メッセージ(Message)**：呼び出し/通知/応答など(シーケンス番号で順序付け)

### シーケンス図との違い(試験でよく問われるポイント)

- **シーケンス図**：縦方向に時間軸を取り、メッセージの「時間順序」を明確に表現
- **コミュニケーション図**：オブジェクトの結び付き/メッセージのやり取りを「ネットワーク構造」に近い形で表現

## シーケンス図(Sequence Diagram)

### 定義と目的

シーケンス図は、**時間の経過に沿って、オブジェクト間でやり取りされるメッセージの順序を表現する相互作用図**です。

### 主な要素

- **ライフライン(Lifeline)**：オブジェクト／アクター
- **アクティベーションバー**：処理中の期間
- **同期／非同期メッセージ**
- **戻りメッセージ(return)**
- **フラグメント(alt/opt/loop/par など)**：制御構造

### 活用イメージ

**プロトコルのシーケンスや API 呼び出しの順序を説明する際に最も適している図**です。

- 認証シーケンス(クライアント → Web サーバ → 認証サーバ)
- 3D セキュアにおけるブラウザ／加盟店／カード会社のやり取り
- OAuth2.0 のリダイレクトフロー

## ユースケース図(Use Case Diagram)

### 定義と目的

ユースケース図は、**システムに対して外部のアクターがどのような目的(ユースケース)で利用するかを俯瞰的に示す図**です。

### 主な要素

- **アクター**：システム外の利用者／外部システム
- **ユースケース**：システムが提供する機能単位
- **システム境界(Subject)**：対象システムの範囲
- **関係**：
  - include：必ず呼び出される共通処理
  - extend：条件により拡張される処理
  - 汎化：アクター／ユースケースの一般化

### 支援士試験での典型的な使われ方

- 情報系システムの「利用者と機能」の全体像を示す
- アクセス制御/権限設計の説明に用いる
- セキュリティ要件を特定のユースケースに紐づけて議論する

## UML 2.x のダイアグラム体系(13～14種)

### 構造図(Structure Diagrams)

- クラス図(Class Diagram)
- オブジェクト図(Object Diagram)
- コンポーネント図(Component Diagram)
- 配置図(Deployment Diagram)
- 複合構造図(Composite Structure Diagram)
- パッケージ図(Package Diagram)
- プロファイル図(Profile Diagram)

### 振る舞い図(Behavior Diagrams)

- ユースケース図(Use Case Diagram)
- アクティビティ図(Activity Diagram)
- 状態マシン図(State Machine Diagram)
- シーケンス図(Sequence Diagram)
- コミュニケーション図(Communication Diagram)
- 相互作用概要図(Interaction Overview Diagram)
- タイミング図(Timing Diagram)

## UML ダイアグラム使い分けの早見表

| 図 | 主な用途 | 時間軸 | 構造の強調 | よくある出題ポイント |
|----|----------|--------|------------|------------------------|
| ユースケース図 | ユーザとシステム機能の関係 | × | △ | 要件定義／アクター/機能の俯瞰 |
| アクティビティ図 | 業務プロセス／処理フロー | △ | × | 分岐／並列／条件遷移の表現 |
| シーケンス図 | オブジェクト間メッセージの時間順序 | ◎ | △ | プロトコル／API 呼び出し順序 |
| コミュニケーション図 | オブジェクトの関係＋メッセージ | △ | ◎ | 構造と振る舞いの両方を把握 |
| クラス図 | クラス/関連/継承構造 | × | ◎ | 静的構造の設計/オブジェクト指向設計 |
