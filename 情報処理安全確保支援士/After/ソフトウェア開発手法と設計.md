# アジャイル開発・オブジェクト指向・デザインパターン・UMLの体系整理

## はじめに

2025年10月のプロジェクトマネージャ試験受験を終え、2026年秋の情報処理安全確保支援士に向けて勉強中です。
本記事を含めた各知識のインデックスや学習の道のりについては、「[情報処理安全確保支援士への道のり(随時更新中)](https://qiita.com/teppei19980914/items/a25279a17b210d6ed9f4)」をご参照ください。
**本記事は学習した内容を記載しています。**

## 該当問題

[情報セキュリティスペシャリスト平成22年春期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/22_haru/am2_22.html)
[情報セキュリティスペシャリスト平成24年秋期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/24_aki/am2_22.html)
[情報セキュリティスペシャリスト平成28年春期 午前Ⅱ 問23](https://www.sc-siken.com/kakomon/28_haru/am2_23.html)
[情報処理安全確保支援士平成30年春期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/30_haru/am2_22.html)
[情報処理安全確保支援士令和5年秋期 午前Ⅱ 問23](https://www.sc-siken.com/kakomon/05_aki/am2_23.html)
[情報処理安全確保支援士令和6年秋期 午前Ⅱ 問22](https://www.sc-siken.com/kakomon/06_aki/am2_22.html)

## アジャイルソフトウェア開発とは

アジャイル(Agile)とは、**変化に適応しながら、反復的/漸進的に価値を提供するソフトウェア開発手法**です。

根拠：

- **アジャイルソフトウェア開発宣言(2001)**
  https://agilemanifesto.org/iso/ja/manifesto.html
- Scrum Guide(公式)
- IPA『アジャイル開発の教科書』

### アジャイルの価値観(Agile Manifesto)

アジャイルでは次の4つを重視します。

1. **プロセスやツールよりも個人と対話を**
2. **包括的な文書よりも動くソフトウェアを**
3. **契約交渉よりも顧客との協調を**
4. **計画に従うよりも変化への対応を**

## アジャイル開発の特徴

| 特徴 | 説明 |
|------|------|
| 反復/短サイクル開発 | 小さく作り、小さく改善する(Iteration/Sprint) |
| 顧客との継続的な協働 | プロダクトオーナーが価値を最大化 |
| 継続的インテグレーション | ビルド/テストを自動化 |
| 要求の変化に強い | 計画より適応を重視 |
| チーム主体性 | 自律的チームによる改善 |

### XP(Extreme Programming)

- 技術プラクティスを重視
- ペアプログラミング、テスト駆動開発(TDD)、CI などが代表

## ペアプログラミング(XPの中核プラクティス)

### ペアプログラミングとは

ペアプログラミング(Pair Programming)とは、**2人1組で 1 台のコンピュータを使い、協力してプログラミングを行う手法**です。

根拠：

- Kent Beck "Extreme Programming Explained"
- XP 公式プラクティスとして定義

### 役割分担

ペアプログラミングには 2 つの役割があります。
一定時間ごとに交代することで品質と理解が向上します。

| 役割 | 説明 |
|------|------|
| **ドライバ(Driver)** | キーボードを操作しコードを書く |
| **ナビゲータ(Navigator)** | レビュー/設計/方針確認など全体的視点で支援 |

### ペアプログラミングのメリット

#### 品質向上

- コードをリアルタイムでレビュー
- バグの早期発見が可能

#### 知識共有(ナレッジシェア)

- 新人育成に有効
- チームの属人化防止

#### 設計改善

- 2 人の視点でアーキテクチャを見直すため設計品質が安定

#### コミュニケーション改善

- チームワークの向上
- 仕様理解のズレ減少

### デメリット

- 工数が増えるように見える
- チームスキルが均一でない場合は効果が低下
- 性格的相性の問題が発生することもある

## アジャイル開発とセキュリティ

SC試験で問われるポイントとして、**アジャイル＝セキュリティが弱い という誤解**への対処があります。
アジャイルでは次のようにセキュリティを内包できます。

- セキュリティ要求を「ユーザストーリー」として管理
- スプリントごとに脆弱性テストを実施
- DevSecOps によりビルド時に自動スキャン
- レビューやペアプロでコード品質が向上

## スクラム(Scrum)とは

Scrum Guide(2020版)で定義されるフレームワークであり、**複雑性(Complexity)の高い課題を反復的/漸進的に解決する開発方法**です。
下記を核として構成されます。

- 明確な役割(3つ)
- 定義されたイベント(5つ)
- 透明性を担保する作成物(3つ)

## スクラムチームと3つの役割

### プロダクトオーナー(Product Owner)

役割：**価値の最大化を担う役割**

#### 主な責任

- プロダクトバックログの作成と優先順位付け
- ステークホルダとの調整
- プロダクト価値の最大化
- プロダクトゴールを策定し明示的に伝えること

#### 特徴

- 1 スプリント内で何を作るか(What)を決める権限を持つ
- 開発チームに「どう作るか(How)」は指示しない

### スクラムマスター(Scrum Master)

役割：**スクラムの理解と実践を促す促進者(ファシリテータ)**

#### 主な責任

- スクラムのルール/価値基準の徹底
- 障害除去(インピーディメント管理)
- チームの自己管理/自律性の支援
- 組織へのスクラム導入支援

#### 特徴

- プロジェクト管理者ではない
- 権限ではなく、コーチングやファシリテーションによる支援が中心

### 開発チーム(Developers)

役割：**実際にプロダクトを作り上げる自律的チーム**

#### 主な責任

- スプリントバックログの作成
- 実装/テスト/ドキュメントなど必要な全作業の遂行
- インクリメントの完成(DoD 準拠)

#### 特徴

- クロスファンクショナル(多能工)
- 自己組織化(Self-Organizing)
- チーム外から指示されない

## スクラムの5つのイベント(Scrum Events)

Scrum Guide で定義される **強制イベント** は以下の5つです。

### スプリント(Sprint)

スクラムの基盤となる反復期間(1～4週間)でスプリント中断は原則禁止されます。

### スプリントプランニング(Sprint Planning)

**「このスプリントで何を作るか」「どのように作るか」を決める会議**のことです。

主要アウトプット：

- スプリントゴール
- スプリントバックログ

### デイリースクラム(Daily Scrum)

毎日15分以内のチームの同期会議のことです。

典型的な確認内容：

- 昨日行ったこと
- 今日行うこと
- 課題/障害の共有

### スプリントレビュー(Sprint Review)

スプリント成果物(インクリメント)をステークホルダに共有し、フィードバックを得るイベントです。

### スプリントレトロスペクティブ(Sprint Retrospective)

チームの**プロセス改善**を議論する振り返りイベントです。

## スクラムの3つの作成物(Artifacts)

### プロダクトバックログ(Product Backlog)

- プロダクトに必要な要求、改善、機能をリスト化したもの
- PO が優先度を管理
- 常に進化し続ける

### スプリントバックログ(Sprint Backlog)

- プロダクトバックログの中からスプリントで実施する項目の集合
- 開発チームが **「どう実施するか」** を細分化し管理する

### インクリメント(Increment)

- スプリントで作られた完成済み成果物
- 「完成の定義(Definition of Done)」を満たす必要がある

## アジャイルとスクラムの違い(整理)

|項目|アジャイル|スクラム|
|---|---|---|
|種別|価値観/思想|具体的フレームワーク|
|文書|アジャイル宣言|Scrum Guide|
|構成要素|原則/価値観|役割/イベント/作成物|
|適用範囲|開発全般|複雑性の高い開発|

## アジャイル周辺知識(SC試験頻出)

### バーンダウンチャート

スプリント残作業量の可視化に利用します。

### ユーザストーリー

要求を簡潔に示す形式です。

> As a(ユーザ)
> I want(機能)
> So that(価値)

### TDD(テスト駆動開発)

テストを書いてからコードを書く XP の中心手法です。

### CI/CD(継続的インテグレーション/デリバリ)

自動ビルド/テスト/デプロイにより価値提供を継続します。

### DevOps/DevSecOps

開発と運用の壁をなくし、セキュリティも統合する考え方です。

## 汎化(Generalization)

### 定義

複数のクラスが共通して持つ属性や操作を抽出し、**より上位の抽象クラス(スーパークラス)としてまとめること**です。

### エビデンス

UML2.0(OMG Unified Modeling Language 2.x 仕様書)で Generalization は「ある分類子が別の分類子の特殊化であることを示す関係」と定義されています。

### 目的

- 重複コード/重複概念の排除
- モデルの簡潔化
- 共通機能の一元管理

### 例

```
動物
 ├─ 犬
 └─ 猫
```
犬/猫に共通する「呼吸する」「歩く」などを「動物」にまとめます。

## 特化(Specialization)

### 定義

汎化の逆に、**上位概念(スーパークラス)をより具体的な下位概念(サブクラス)に分ける操作**です。

### 目的

- 振る舞いの差異を明確化
- 特定属性/操作の追加

### 例

```
従業員
 ├─ 正社員(給与形態：月給)
 └─ アルバイト(給与形態：時給)
```

## 継承(Inheritance)

### 定義

サブクラスがスーパークラスの **属性/メソッドを受け継ぐ** 機能です。

### エビデンス

オブジェクト指向言語(Java, C++, Python 等)でも共通して「コード再利用」「多様性(ポリモーフィズム)の基盤」とされます。

### 特徴

- **IS-A関係**(〜は〜の一種)を表す
- サブクラスはスーパークラスの振る舞いを拡張/上書きできる(オーバーライド)

## サブクラス(Subclass)

### 定義

スーパークラスを継承し、より具体的な属性/振る舞いを持つクラスです。

### ポイント

- スーパークラスの性質＋独自機能を持つ
- Liskov Substitution Principle(LSP)を満たす必要がある
    → サブクラスはスーパークラスとして置き換えても問題なく振る舞うべき

## 汎化/特化/継承の違い(試験で問われるポイント)

| 概念 | 方向性 | モデリング上の役割 |
|------|--------|----------------------|
| 汎化 | 下位 → 上位 | 共通性の抽出、抽象化 |
| 特化 | 上位 → 下位 | 具体化、差異の明確化 |
| 継承 | 設計/実装 | 属性/メソッドの引継ぎ |

## 情報隠蔽との関係

### 情報隠蔽(Information Hiding)

- クラス内部のデータ構造/実装を外部から隠すこと
- 外部に公開するのは **必要なインタフェースのみ**

### 継承と情報隠蔽の注意点

継承を使うと、スーパークラスの内部構造に依存した実装になりがちです。
そのため **継承より合成(Composition over Inheritance)** が推奨される場合も多いです。

## スーパークラス設計時の注意点

- 不必要に抽象クラスを増やすと複雑化する
- 共通化は「本当に共通の性質」に限定
- 多重継承は言語によっては問題を生む(C++ は可、Java は不可)

## SOLID 原則(高度試験頻出)

- **S**：単一責任原則
- **O**：開放閉鎖原則(変更に閉じ、拡張に開く)
- **L**：リスコフの置換原則
- **I**：インターフェース分離原則
- **D**：依存性逆転原則

→ いずれも **情報隠蔽/疎結合** の思想に基づきます。

## オブジェクト指向のメリット

- 再利用性
- 保守性
- 拡張性
- モジュール化

## 関数型や手続き型との比較

| 手法 | 特徴 |
|------|------|
| 手続き型 | 処理手順が中心、データと処理が分離 |
| 関数型 | 副作用排除、状態変更を嫌う |
| オブジェクト指向 | データ中心、責務分担が明確 |

## ソフトウェアパターンとは

### 定義(エビデンス)

- Christopher Alexander
- Gamma et al., *Design Patterns: Elements of Reusable Object-Oriented Software*
- POSA(Pattern-Oriented Software Architecture)

**ソフトウェアパターンとは、繰り返し発生する設計上の問題に対して、実績のある解決策を再利用可能な形でまとめた知識体系です。**

重要なのは「**コード断片**」ではなく、下記をセットで表現する点です。

- 問題(Context)
- 解決すべき課題(Problem)
- 解決方法(Solution)
- 効果/トレードオフ(Consequences)

## ソフトウェアパターンの階層分類(試験重要)

ソフトウェアパターンは、適用レベルにより次のように分類されます。

### アーキテクチャパターン

#### 特徴

- システム全体構造を規定
- 高レベル設計

#### 代表例

- MVC(Model–View–Controller)
- レイヤードアーキテクチャ
- クライアント／サーバ
- マイクロサービス

→ **「システムの骨格」を決めます**

### デザインパターン(GoF)

#### 特徴

- クラス/オブジェクト間の設計指針
- オブジェクト指向設計の再利用知識

### イディオム(実装パターン)

#### 特徴

- 特定言語に依存
- コーディングレベル

#### 例

- Java の try-with-resources
- C++ の RAII

## GoF(Gang of Four)とは

### GoF の位置付け(エビデンス)

- Erich Gamma
- Richard Helm
- Ralph Johnson
- John Vlissides

1994年に以下の名著を出版し、この書籍で **23個のデザインパターン** が体系化されました。
***Design Patterns: Elements of Reusable Object-Oriented Software***

## GoF デザインパターンの全体構成

GoF のデザインパターンは、目的別に **3分類** されます。

```
GoF デザインパターン(全23)
├─ 生成(Creational) : 5
├─ 構造(Structural) : 7
└─ 振る舞い(Behavioral) : 11
```

## 生成パターン(Creational Patterns)

### 目的

- **オブジェクト生成方法を抽象化**
- new の乱用を防止

### 代表例

| パターン | 概要 |
|---|---|
| Singleton | インスタンスを1つに制限 |
| Factory Method | 生成処理をサブクラスに委譲 |
| Abstract Factory | 関連オブジェクト群を生成 |
| Builder | 構築手順と表現を分離 |
| Prototype | 複製による生成 |

## 構造パターン(Structural Patterns)

### 目的

- **クラスやオブジェクトの構造を柔軟に構成**
- 変更に強い設計

### 代表例

| パターン | 概要 |
|---|---|
| Adapter | インタフェース変換 |
| Decorator | 機能を動的に追加 |
| Composite | 木構造を一様に扱う |
| Facade | 窓口を単純化 |
| Proxy | 代理制御 |

## 振る舞いパターン(Behavioral Patterns)

### 目的

- **オブジェクト間の責務分担と通信制御**

### 代表例

| パターン | 概要 |
|---|---|
| Observer | 状態変化の通知 |
| Strategy | アルゴリズム切替 |
| Command | 処理をオブジェクト化 |
| Template Method | 処理骨格を定義 |
| State | 状態に応じて振る舞い変更 |

## ソフトウェアパターンとフレームワークの違い

| 項目 | パターン | フレームワーク |
|---|---|---|
| 形態 | 抽象的知識 | 具体的コード |
| 再利用 | 思想/設計 | 実装 |
| 例 | MVC, GoF | Spring, Struts |

## アーキテクチャパターンとの関係

- MVC は **アーキテクチャパターン**
- MVC 内部実装で GoF が使われる

例：
- Observer(View更新)
- Strategy(入力処理切替)

## アンチパターン

### 定義

- 一見よさそうだが、実際には問題を悪化させる設計

### 例

- God Object
- Spaghetti Code
- Golden Hammer

## UML 2.x の概要

UML(Unified Modeling Language)は、OMG(Object Management Group)が標準化している**システム/ソフトウェアの構造と振る舞いを可視化するためのモデリング言語**です。

UML 2.x では、ダイアグラムは大きく以下に分類されます。

- **構造図(Structure Diagrams)**：静的な構造／クラス／コンポーネント／配置など
- **振る舞い図(Behavior Diagrams)**：動作やオブジェクト間のやり取り(相互作用)など

試験的には、以下を分類できることが重要です。

- 「どの図が"構造"を表すのか」
- 「どの図が"振る舞い／相互作用"を表すのか」

## アクティビティ図(Activity Diagram)

### 定義と目的

アクティビティ図は、**アクション(処理)の実行順序や分岐/並行/結合などを表現する図**です。ビジネスプロセスやワークフロー、アルゴリズム手順などをモデル化するのに適しています。

### 主な要素

- **アクション(Action)**：アクティビティ内の最小の実行単位
- **開始ノード／終了ノード**：ワークフローの開始/終了を表す
- **制御フロー／オブジェクトフロー**：制御の流れ／データの流れを矢印で表現
- **分岐(Decision)/マージ(Merge)**：条件による分岐／条件の合流
- **フォーク(Fork)/ジョイン(Join)**：並列実行の開始／同期

### 活用イメージ(支援士的観点)

- 認証プロセス(ID/パスワード入力 → 認証サーバ照会 → 成功／失敗)
- インシデント対応フロー
- 承認ワークフロー(申請 → 承認 → 払出 等)

## コミュニケーション図(Communication Diagram)

### 定義と目的

コミュニケーション図(UML 1.x ではコラボレーション図)は、**オブジェクト(または役割)間の関係と、その間でやり取りされるメッセージの流れを表現する相互作用図**です。

### 主な要素

- **ライフライン(Lifeline)**：オブジェクトやクラスのインスタンス
- **リンク(Association/Connector)**：オブジェクト間の関連
- **メッセージ(Message)**：呼び出し/通知/応答など(シーケンス番号で順序付け)

### シーケンス図との違い(試験でよく問われるポイント)

- **シーケンス図**：縦方向に時間軸を取り、メッセージの「時間順序」を明確に表現
- **コミュニケーション図**：オブジェクトの結び付き/メッセージのやり取りを「ネットワーク構造」に近い形で表現

## シーケンス図(Sequence Diagram)

### 定義と目的

シーケンス図は、**時間の経過に沿って、オブジェクト間でやり取りされるメッセージの順序を表現する相互作用図**です。

### 主な要素

- **ライフライン(Lifeline)**：オブジェクト／アクター
- **アクティベーションバー**：処理中の期間
- **同期／非同期メッセージ**
- **戻りメッセージ(return)**
- **フラグメント(alt/opt/loop/par など)**：制御構造

### 活用イメージ

**プロトコルのシーケンスや API 呼び出しの順序を説明する際に最も適している図**です。

- 認証シーケンス(クライアント → Web サーバ → 認証サーバ)
- 3D セキュアにおけるブラウザ／加盟店／カード会社のやり取り
- OAuth2.0 のリダイレクトフロー

## ユースケース図(Use Case Diagram)

### 定義と目的

ユースケース図は、**システムに対して外部のアクターがどのような目的(ユースケース)で利用するかを俯瞰的に示す図**です。

### 主な要素

- **アクター**：システム外の利用者／外部システム
- **ユースケース**：システムが提供する機能単位
- **システム境界(Subject)**：対象システムの範囲
- **関係**：
  - include：必ず呼び出される共通処理
  - extend：条件により拡張される処理
  - 汎化：アクター／ユースケースの一般化

### 支援士試験での典型的な使われ方

- 情報系システムの「利用者と機能」の全体像を示す
- アクセス制御/権限設計の説明に用いる
- セキュリティ要件を特定のユースケースに紐づけて議論する

## UML 2.x のダイアグラム体系(13～14種)

### 構造図(Structure Diagrams)

- クラス図(Class Diagram)
- オブジェクト図(Object Diagram)
- コンポーネント図(Component Diagram)
- 配置図(Deployment Diagram)
- 複合構造図(Composite Structure Diagram)
- パッケージ図(Package Diagram)
- プロファイル図(Profile Diagram)

### 振る舞い図(Behavior Diagrams)

- ユースケース図(Use Case Diagram)
- アクティビティ図(Activity Diagram)
- 状態マシン図(State Machine Diagram)
- シーケンス図(Sequence Diagram)
- コミュニケーション図(Communication Diagram)
- 相互作用概要図(Interaction Overview Diagram)
- タイミング図(Timing Diagram)

## UML ダイアグラム使い分けの早見表

| 図 | 主な用途 | 時間軸 | 構造の強調 | よくある出題ポイント |
|----|----------|--------|------------|------------------------|
| ユースケース図 | ユーザとシステム機能の関係 | × | △ | 要件定義／アクター/機能の俯瞰 |
| アクティビティ図 | 業務プロセス／処理フロー | △ | × | 分岐／並列／条件遷移の表現 |
| シーケンス図 | オブジェクト間メッセージの時間順序 | ◎ | △ | プロトコル／API 呼び出し順序 |
| コミュニケーション図 | オブジェクトの関係＋メッセージ | △ | ◎ | 構造と振る舞いの両方を把握 |
| クラス図 | クラス/関連/継承構造 | × | ◎ | 静的構造の設計/オブジェクト指向設計 |

## ソフトウェア開発モデルの比較

### 主要な開発モデル

| 開発モデル | 特徴 | 適用場面 |
|---|---|---|
| **ウォーターフォールモデル** | 要件定義→設計→実装→テスト→運用を**順序的に実施**。前工程に戻りにくい | 要件が明確で変更が少ないシステム |
| **V字モデル** | ウォーターフォールの各開発工程に対応する**テスト工程を明示** | テストの網羅性が重要なシステム |
| **スパイラルモデル** | **リスク分析**を繰り返しながら段階的に開発 | リスクの高い大規模システム |
| **プロトタイピングモデル** | 試作品を作成し、ユーザの要求を確認しながら開発 | 要件が不明確なシステム |
| **アジャイル開発** | 短いイテレーションで反復的・漸進的に開発 | 要件の変化が多いシステム |

### V字モデルの対応関係(試験頻出)

| 開発工程(左側) | 対応するテスト工程(右側) |
|---|---|
| 要件定義 | **受入テスト(UAT)** |
| 基本設計(外部設計) | **システムテスト(総合テスト)** |
| 詳細設計(内部設計) | **結合テスト** |
| プログラム設計(コーディング) | **単体テスト** |

> V字モデルの対応関係は試験で非常に頻出です。

## セキュア開発ライフサイクル(Secure SDLC)

### セキュリティ・バイ・デザイン(Security by Design)

セキュリティ・バイ・デザインとは、**開発の初期段階(設計段階)からセキュリティを組み込む考え方**です。

> 後付けのセキュリティ対策ではなく、**設計時点からセキュリティを考慮**することで、手戻りコストを削減し、より堅牢なシステムを構築できます。

### Secure SDLC の各フェーズとセキュリティ活動

| 開発フェーズ | セキュリティ活動 |
|---|---|
| **要件定義** | セキュリティ要件の定義、リスク分析、法規制の確認 |
| **設計** | **脅威モデリング(STRIDE等)**、セキュリティアーキテクチャ設計、攻撃面の分析 |
| **実装** | **セキュアコーディング**、コードレビュー、静的解析(SAST) |
| **テスト** | セキュリティテスト(DAST)、**ファジング**、**ペネトレーションテスト** |
| **リリース** | セキュリティレビュー、脆弱性スキャン、リリース承認 |
| **運用・保守** | 脆弱性管理、パッチ管理、インシデント対応、ログ監視 |

### Microsoft SDL(Security Development Lifecycle)

Microsoft が提唱するセキュア開発プロセスです。

| フェーズ | 活動内容 |
|---|---|
| トレーニング | 開発者へのセキュリティ教育 |
| 要件 | セキュリティ要件の定義、品質ゲートの設定 |
| 設計 | 脅威モデリング、攻撃面の削減 |
| 実装 | セキュアコーディング規約の適用、禁止API の排除 |
| 検証 | 静的解析、動的解析、ファジング |
| リリース | インシデント対応計画の策定、最終セキュリティレビュー |
| 対応 | インシデント対応の実施 |

## 脅威モデリング(Threat Modeling)

### 定義

脅威モデリングとは、**システムの設計段階で、想定される脅威を体系的に洗い出し、対策を検討するプロセス**です。

### STRIDE モデル(試験頻出)

Microsoft が提唱した脅威の分類フレームワークです。

| 頭文字 | 脅威 | 説明 | 対応するセキュリティ特性 |
|---|---|---|---|
| **S** | **Spoofing(なりすまし)** | 他のユーザやシステムになりすます | 認証 |
| **T** | **Tampering(改ざん)** | データやコードを不正に変更 | 完全性 |
| **R** | **Repudiation(否認)** | 行為を否認する(ログ改ざん等) | 否認防止 |
| **I** | **Information Disclosure(情報漏洩)** | 機密情報への不正アクセス | 機密性 |
| **D** | **Denial of Service(サービス拒否)** | サービスを利用不能にする | 可用性 |
| **E** | **Elevation of Privilege(権限昇格)** | 権限を不正に昇格させる | 認可 |

### 脅威モデリングの手順

```
1. 対象システムのモデル化(DFD：データフロー図の作成)
2. 脅威の識別(STRIDEを適用して各要素の脅威を洗い出す)
3. 脅威のリスク評価(影響度×発生可能性)
4. 対策の検討と実装
5. 対策の検証
```

### 攻撃面の分析(Attack Surface Analysis)

攻撃面(Attack Surface)とは、**システムに対して攻撃者がアクセス可能な全てのポイント**です。

| 攻撃面の例 | 具体例 |
|---|---|
| ネットワーク攻撃面 | 公開ポート、API エンドポイント |
| ソフトウェア攻撃面 | 入力フォーム、ファイルアップロード |
| 人的攻撃面 | ソーシャルエンジニアリング |

> 設計段階で**攻撃面を最小化(Attack Surface Reduction)**することが重要です。

## セキュアコーディング

### 定義

セキュアコーディングとは、**脆弱性の作り込みを防ぐためのコーディング原則・技法**です。

### セキュアコーディングの基本原則(試験頻出)

| 原則 | 説明 |
|---|---|
| **入力値の検証(Input Validation)** | 全ての入力データをホワイトリスト方式で検証 |
| **出力のエスケープ(Output Encoding)** | 出力先に応じた適切なエスケープ処理(XSS対策等) |
| **最小権限の原則** | プログラムの実行権限を必要最小限に |
| **デフォルト拒否(Fail Secure)** | エラー時は安全側に倒す(アクセス拒否等) |
| **多層防御(Defense in Depth)** | 単一の対策に依存せず、複数の防御層を設ける |
| **安全なエラー処理** | エラーメッセージに内部情報を含めない |
| **認証と認可の徹底** | 全てのリクエストで認証・認可を検証 |

### 代表的な脆弱性とセキュアコーディング対策

| 脆弱性 | セキュアコーディング対策 |
|---|---|
| **SQLインジェクション** | プリペアドステートメント(バインド変数)の使用 |
| **XSS(クロスサイトスクリプティング)** | 出力時のHTMLエスケープ、CSP の設定 |
| **バッファオーバーフロー** | 境界チェック、安全な関数の使用(strncpy等) |
| **OSコマンドインジェクション** | 外部コマンドの直接呼び出しを回避、引数のエスケープ |
| **ディレクトリトラバーサル** | パスの正規化、ベースディレクトリの制限 |
| **整数オーバーフロー** | 演算前の範囲チェック、安全な型の使用 |

### バッファオーバーフロー対策(午後問題で重要)

#### バッファオーバーフローとは

プログラムが確保したメモリ領域(バッファ)を超えてデータを書き込むことで、**隣接するメモリ領域を破壊する脆弱性**です。

#### 攻撃手法

| 攻撃手法 | 説明 |
|---|---|
| **スタックバッファオーバーフロー** | スタック上のリターンアドレスを上書きし、任意コードを実行 |
| **ヒープオーバーフロー** | ヒープ領域の管理情報を破壊 |

#### OS/コンパイラレベルの対策

| 対策 | 説明 |
|---|---|
| **ASLR(Address Space Layout Randomization)** | メモリ配置をランダム化し、攻撃先アドレスの予測を困難に |
| **DEP/NX(Data Execution Prevention)** | データ領域でのコード実行を禁止 |
| **スタックカナリア(Stack Canary)** | リターンアドレスの前に検知用の値を配置 |
| **SSP(Stack Smashing Protection)** | コンパイラによるスタック破壊検知機能(GCC の -fstack-protector) |

## セキュリティテスト手法

### テスト手法の分類(試験頻出)

| テスト手法 | 説明 | 実施タイミング |
|---|---|---|
| **SAST(Static Application Security Testing)** | ソースコードを実行せずに解析(静的解析) | 実装フェーズ |
| **DAST(Dynamic Application Security Testing)** | 実行中のアプリケーションを外部から検査(動的解析) | テストフェーズ |
| **IAST(Interactive AST)** | SAST と DAST を組み合わせた手法 | テストフェーズ |
| **SCA(Software Composition Analysis)** | 使用しているOSSライブラリの既知脆弱性を検査 | 実装〜運用 |
| **ファジング(Fuzz Testing)** | **大量の異常データ(ファズ)を自動的に入力**し、予期しない動作を検出 | テストフェーズ |
| **ペネトレーションテスト** | 攻撃者の視点でシステムに侵入を試みる | テスト〜運用 |
| **コードレビュー** | 人手によるソースコードの確認 | 実装フェーズ |

### SAST vs DAST(試験で必ず問われる比較)

| 比較項目 | SAST(静的解析) | DAST(動的解析) |
|---|---|---|
| 解析対象 | ソースコード/バイトコード | 実行中のアプリケーション |
| 実行の要否 | **不要**(コードのみで解析) | **必要**(実行環境が必要) |
| 検出できる脆弱性 | コーディングミス、ハードコードされた認証情報 | 実行時に発現する脆弱性(認証バイパス等) |
| 誤検知(False Positive) | 多い | 少ない |
| カバレッジ | 広い(コード全体) | 狭い(テストケース依存) |
| タイミング | 開発初期(シフトレフト) | テスト以降 |

### ファジング(Fuzz Testing)(試験頻出)

ファジングとは、**プログラムの入力に大量の異常なデータ(ファズ)を自動的に送り込み、予期しない動作(クラッシュ、メモリリーク等)を検出するテスト手法**です。

| 項目 | 内容 |
|---|---|
| 長所 | 未知の脆弱性を発見可能、自動化が容易 |
| 短所 | 論理的な脆弱性(認可の不備等)は検出困難 |
| 対象 | プロトコル実装、ファイルパーサ、API |
| ツール例 | AFL(American Fuzzy Lop)、libFuzzer |

## DevSecOps

### 定義

DevSecOps とは、**DevOps のプロセスにセキュリティ(Sec)を統合し、開発・セキュリティ・運用の全員がセキュリティに責任を持つアプローチ**です。

### DevOps との違い

| 比較項目 | DevOps | DevSecOps |
|---|---|---|
| 焦点 | 開発と運用の連携 | 開発・セキュリティ・運用の**三位一体** |
| セキュリティ | 後付け(リリース前テスト) | **全フェーズに組み込み(シフトレフト)** |
| テスト | 機能テスト中心 | セキュリティテストも自動化 |

### シフトレフト(Shift Left)

シフトレフトとは、**セキュリティ活動を開発ライフサイクルの早い段階(左側)に前倒しする考え方**です。

| 従来 | シフトレフト後 |
|---|---|
| リリース前にセキュリティテスト | **設計段階から脅威モデリング** |
| テストフェーズでDAST | **実装時にSAST/コードレビュー** |
| 運用で脆弱性発見→修正 | **CI/CDパイプラインに自動スキャン組込** |

> 「**早期に発見するほど修正コストが低い**」がシフトレフトの根本思想です。

### CI/CD パイプラインにおけるセキュリティ

```
コード作成 → SAST → ビルド → DAST → SCA → セキュリティゲート → デプロイ
             ↑                                    ↑
        静的コード解析              脆弱性があれば自動で
        (コミット時)                デプロイをブロック
```

## ソフトウェア開発とセキュリティの全体整理

### 開発フェーズとセキュリティ活動の対応表

| 開発フェーズ | セキュリティ活動 | 手法・ツール |
|---|---|---|
| 要件定義 | セキュリティ要件の定義 | STRIDE、リスク分析 |
| 設計 | 脅威モデリング、攻撃面分析 | DFD、STRIDE、攻撃ツリー |
| 実装 | セキュアコーディング | SAST、コードレビュー、SCA |
| テスト | セキュリティテスト | DAST、ファジング、ペネトレーションテスト |
| リリース | セキュリティレビュー | 脆弱性スキャン、セキュリティゲート |
| 運用 | 脆弱性管理・監視 | パッチ管理、ログ監視、EDR |

### セキュリティテスト手法の使い分け

| 手法 | ホワイトボックス/ブラックボックス | 自動化 | 検出できる脆弱性の例 |
|---|---|---|---|
| **SAST** | ホワイトボックス | 可能 | SQLi、XSS、ハードコード認証情報 |
| **DAST** | ブラックボックス | 可能 | 認証バイパス、セッション管理不備 |
| **ファジング** | ブラックボックス | 可能 | バッファオーバーフロー、クラッシュ |
| **ペネトレーションテスト** | 両方 | 一部可能 | 複合的な脆弱性、ビジネスロジックの欠陥 |
| **コードレビュー** | ホワイトボックス | 不可 | 設計上の問題、ロジックの誤り |
