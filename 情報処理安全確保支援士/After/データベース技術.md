# リレーショナルデータベースの設計・制約・分散処理の体系整理

## はじめに

2025年10月のプロジェクトマネージャ試験受験を終え、2026年秋の情報処理安全確保支援士に向けて勉強中です。
本記事を含めた各知識のインデックスや学習の道のりについては、「[情報処理安全確保支援士への道のり(随時更新中)](https://qiita.com/teppei19980914/items/a25279a17b210d6ed9f4)」をご参照ください。
**本記事は学習した内容を記載しています。**

## 該当問題

[情報セキュリティスペシャリスト平成22年秋期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/22_aki/am2_21.html)
[情報セキュリティスペシャリスト平成24年春期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/24_haru/am2_21.html)
[情報セキュリティスペシャリスト平成25年秋期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/25_aki/am2_21.html)
[情報セキュリティスペシャリスト平成26年春期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/26_haru/am2_21.html)
[情報セキュリティスペシャリスト平成27年春期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/27_haru/am2_21.html)
[情報処理安全確保支援士令和3年秋期 午前Ⅱ 問21](https://www.sc-siken.com/kakomon/03_aki/am2_21.html)

## 関係モデル

データを行(タプル)と列(属性)からなる関係(Relation)で表現するデータモデルで、現在のRDB(Relational Database)の基礎となっています。

## SQL における制約(Constraint)とは

制約とは **データの正確性/一貫性/整合性を保証するためのルール** であり、ACID特性のうち「一貫性(Consistency)」を担保する重要な仕組みです。

## NOT NULL 制約

### 意味

列に **NULL が入ることを禁止**します。

### 例

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name    VARCHAR(50) NOT NULL
);
```

### 特徴

- INSERT/UPDATE で NULL を入れるとエラー
- 空文字列 ("") と NULL は別扱い

## CHECK 制約

### 意味

列の値が **指定した条件を満たす場合のみ許可** します。

### 例

```sql
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    age    INT CHECK(age BETWEEN 0 AND 150),
    grade  CHAR(1) CHECK(grade IN ('A','B','C'))
);
```

### 特徴

- 条件違反時はエラー
- RDBMS によりサポート差あり(MySQL 8.0 未満は無視)

## UNIQUE 制約(重複禁止)

### 意味

列、または列の組が **重複してはいけません**。

### 例

```sql
CREATE TABLE accounts (
    account_id INT PRIMARY KEY,
    email      VARCHAR(255) UNIQUE
);
```

複数列のユニークも可能です。

```sql
UNIQUE (room_id, reserved_day)
```

### 特徴

- NULL は複数許可(SQL標準)
- 多くのDBで自動的にインデックス作成

## PRIMARY KEY 制約(主キー)

### 意味

行を一意に識別するキーです。

#### 主キーの性質

- NOT NULL
- UNIQUE
- 1表に1つだけ定義可能

### 例

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name       VARCHAR(50)
);
```

複合主キーの例です。

```sql
PRIMARY KEY(student_id, subject_id)
```

## FOREIGN KEY 制約(参照整合性制約)

### 意味

他表の **主キーまたは UNIQUE 列** を参照し、整合性を保証します。

### 例

```sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY
);

CREATE TABLE orders (
    order_id    INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
);
```

### 参照整合性の保持

* 参照元には参照先に存在しない値を挿入できない
* 参照先の行が削除されたら、参照元の整合性を保つための動作が必要

## 外部キーの参照アクション(ON DELETE/ON UPDATE)

| アクション | 動作 |
|-----------|------|
| NO ACTION | 不整合があれば拒否 |
| RESTRICT  | 参照されていれば削除/更新不可 |
| CASCADE   | 親の削除/更新を子へ伝播 |
| SET NULL  | 親削除時に子を NULL |
| SET DEFAULT | 既定値を設定 |

例：

```sql
FOREIGN KEY(customer_id)
  REFERENCES customers(customer_id)
  ON DELETE CASCADE
  ON UPDATE CASCADE;
```

## ALTER TABLE による制約追加/削除

### 追加

```sql
ALTER TABLE users
  ADD CONSTRAINT email_unique UNIQUE(email);
```

### 削除

```sql
ALTER TABLE users
  DROP CONSTRAINT email_unique;
```

## 正規化

データの重複や不整合を防ぐため、表を段階的に構造化する手法です。

### 正規化の段階

#### 第1正規形

第1正規形では、下記2点を実施します。

* 繰り返し属性を排除
* 分割不可能な単位となるように分割

#### 第2正規形

第2正規形では、下記1点を実施します。

* 部分関数従属を排除

#### 第3正規形

第3正規形では、下記1点を実施します。

* 推移的関数従属を排除

## ACID特性

データベースのトランザクション処理が持つべき4つの性質のことです。

|特性|意味|
|:----|:----|
|Atomicity(原子性)|全部成功 or 全部失敗|
|Consistency(一貫性)|制約を常に満たす|
|Isolation(独立性)|他トランザクションの影響を受けない|
|Durability(永続性)|コミット後は永続保存|

## ロックと分離レベル

### ロックの種類

ロックには下記2つがあります。

* 共有ロック
* 排他ロック

### 分離レベル

* READ UNCOMMITTED
* READ COMMITTED
* REPEATABLE READ
* SERIALIZABLE

## 関係演算(Relational Algebra)の体系整理

関係演算は **関係データベースの理論的基盤**であり、SQL の構文の多くは関係演算を基に設計されています。

### 基本演算(5つ)

#### 選択(Selection：σ)

行を条件で絞り込む演算です。
SQL の **WHERE** に対応しています。

例(年齢>=20 の社員)：

```
σ age >= 20 (Employees)
```

#### 射影(Projection：π)

列を抽出する演算です。
SQL の **SELECT 列名** に対応します。

例：

```
π name, age (Employees)
```

#### 直積(Cartesian Product：×)

2つの関係をすべての組み合わせで結合します。
SQL の **CROSS JOIN** に対応しています。

#### 和(Union：∪)

2つの関係の和集合(重複削除)です。
SQL の **UNION** に対応します。

#### 差(Difference：−)

片方にしか存在しない行を取得します。
SQL の **EXCEPT/MINUS** に対応します。

### 派生演算(応用演算)

#### 共通(Intersection：∩)

共通する行を抽出します。
SQL の **INTERSECT** に対応します。

#### 結合(Join)

SQL JOIN の原型です。
自然結合/等値結合などが含まれます。

例：

```
Employees ⋈ Employees.dept_id = Departments.dept_id Departments
```

#### 商(Division：÷)

「すべての条件を満たす行」を求める演算です。
SQL に直接の構文はなく、NOT EXISTS や HAVING COUNT で表現します。

## SQL の4大命令(DML)

### SELECT(検索)

```sql
SELECT name, age FROM employees WHERE age >= 20;
```

### INSERT(追加)

```sql
INSERT INTO employees (id, name, age) VALUES (1, 'Taro', 30);
```

### UPDATE(更新)

```sql
UPDATE employees SET age = age + 1 WHERE id = 1;
```

### DELETE(削除)

```sql
DELETE FROM employees WHERE id = 1;
```

## SQL の周辺知識

### JOIN の種類

- INNER JOIN
- LEFT/RIGHT OUTER JOIN
- FULL OUTER JOIN

### GROUP BY と HAVING

集約後の条件は HAVING です。

### ビュー(VIEW)

複雑なクエリを仮想表として再利用します。

### インデックス

検索性能改善(B+tree/Hash)に使用します。

### GRANT文

#### 何を付与するか（Privilege）

表・ビュー等のDBオブジェクトに対する権限（例：SELECT/INSERT/UPDATE/DELETE等）を主体（ユーザ・ロール等）に付与します。

#### 誰に付与するか（User / Role / PUBLIC）

多くのDBでは「ユーザ」「ロール（役割）」「PUBLIC（全員に相当する集合）」に付与できます。
ただし、**PUBLICは"全権付与"ではありません**。単に「対象集合が広い」だけです（付与される権限の種類・範囲はGRANT句で明示したものに限定されます）。

#### WITH GRANT OPTION（付与権）の意味

##### 何が起きるか

`WITH GRANT OPTION` を付けると、**受領者は「その権限をさらに他者へGRANTできる」**ようになります。
逆に言えば、これが無い場合は「自分は使えるが、他人へ配れない」です。

##### リスク

付与権は"権限の拡散"を招きやすいので、運用上は最小権限の観点から慎重に扱います。

##### REVOKEとの関係（CASCADEが絡む典型論点）

付与権で連鎖的に権限が配られた後に取り消すと、**連鎖（依存関係）**が発生します。
例えばSQL Serverの説明では、GRANT OPTIONで与えられた権限を取り消す際にCASCADEを付けないと失敗し得る旨が示されています。
製品差はありますが、「付与権は撤回が難しくなり得る」という実務的ポイントは共通理解として重要です。

### ビューと権限

- ビューは「表のように見せる論理オブジェクト」であり、参照権限（SELECT）の付与対象になり得ます
- ただし、ビューの定義や実装によっては、基表権限や所有者権限（definer/invokerの扱い）など追加論点が出ます

### ER 図と外部キー

- 1対多は外部キーで表現
- 多対多は中間テーブル(交差テーブル)を用います

## 分散データベースシステムとは

分散データベースシステム(Distributed Database System)とは、物理的に異なる複数のコンピュータに配置されたデータベースを、論理的には一つのデータベースとして利用できるようにしたシステムです。
C.J. Date や ISO/IEC による定義では、分散データベースの本質は次の点にあります。

- データは複数拠点に分散配置されている
- 利用者やアプリケーションからは単一のデータベースとして見える
- 分散による複雑さは DBMS が吸収する

**この「分散を意識させない」ための性質を 透過性(Transparency) と呼びます。**

## 透過性(Transparency)の基本概念

透過性とは、分散によって生じる内部構造/配置/制御の違いを、利用者に意識させない性質を指します。
分散データベースシステムの評価軸は、「どれだけ多くの透過性を実現できているか」に集約されます。

### 分割に対する透過性(Fragmentation Transparency)

分割に対する透過性とは、データが分割されて格納されていることを、利用者が意識せずに利用できる性質です。
分割には次の代表例があります。

- 水平分割(行単位で分割)
- 垂直分割(列単位で分割)

利用者は通常の SQL 文を用いるだけでよく、どの分割片を参照しているかを意識する必要はありません。

### 位置に対する透過性(Location Transparency)

位置に対する透過性とは、データがどの物理的拠点に存在するかを、利用者が意識しなくてよい性質のことです。
分散データベースにおいて、最も基本的な透過性の一つです。

### 移動に対する透過性(Migration Transparency)

移動に対する透過性とは、データが拠点間で移動しても、アプリケーションを変更せずに利用できる性質です。
位置透過性が「現在どこにあるか」を隠すのに対し、移動透過性は「場所が変わること自体」を隠す点が異なります。

### 複製に対する透過性(Replication Transparency)

複製に対する透過性とは、データが複数コピー(レプリカ)されていることを利用者に意識させない性質です。
この透過性により、以下が実現されます。

- 可用性の向上(障害時の代替)
- 読み取り性能の向上

レプリカ間の整合性や同期処理は DBMS が管理し、利用者は単一のデータとして扱えます。

### 障害に対する透過性(Failure Transparency)

障害に対する透過性とは、一部のノードや通信に障害が発生しても、利用者にその影響を感じさせない性質のことです。
重要なのは、**障害が起きないこと**ではなく**障害が起きても見せないこと**です。

### データモデルに対する透過性(Data Model Transparency)

データモデルに対する透過性とは、内部で使用されているデータモデルの違いを、利用者に意識させない性質です。
異種システム統合やレガシー移行で重要となります。

### 透過性の整理(試験向け一覧)

| 透過性 | 隠す対象 |
|---|---|
| 分割に対する透過性 | 分割方法 |
| 位置に対する透過性 | 存在場所 |
| 移動に対する透過性 | 移動 |
| 複製に対する透過性 | コピーの存在 |
| 障害に対する透過性 | 障害の影響 |
| データモデルに対する透過性 | 内部構造 |

## 2相コミットプロトコル(Two-Phase Commit Protocol, 2PC)

### 定義(エビデンス：Gray & Reuter, Transaction Processing/ISO/IEC)

**2相コミットプロトコル(2PC)**とは、**分散トランザクションにおいて、複数の参加ノード(参加者)がすべて同じ判断(コミット or アボート)を行うことを保証するためのコミット制御プロトコル**です。
目的は、**分散環境でも「トランザクションの原子性」を保証すること**です。

## 分散トランザクションと課題

### 単一DBとの違い

| 単一データベース | 分散データベース |
|---|---|
| ローカルログで制御可能 | 複数ノードの協調が必要 |
| 障害範囲が限定 | ネットワーク障害が発生 |
| COMMITは一箇所 | COMMIT判断を揃える必要 |

→ **「一部だけ更新される」状態が最も危険**です。

## 2相コミットの基本構造

### 登場人物

| 役割 | 説明 |
|---|---|
| コーディネータ(Coordinator) | トランザクション全体を管理 |
| 参加者(Participant) | 各データベース／ノード |

## 2相コミットの処理手順(最重要)

### 第1相：準備フェーズ(Prepare Phase)

1. コーディネータが各参加者に **「コミット可能か？」** を問い合わせ
2. 各参加者は以下を実施
   - 更新内容をログに書き込み(Undo/Redoログ)
   - ロックを保持したまま
   - **Yes(準備完了) or No(不可)** を返信

→ この時点では **まだ確定していない**

### 第2相：確定フェーズ(Commit Phase)

#### 全参加者が Yes の場合

1. コーディネータが **COMMIT 指示**
2. 各参加者がコミット実行
3. ロック解放

#### 1つでも No があった場合

1. コーディネータが **ABORT(ROLLBACK)指示**
2. 各参加者がロールバック
3. ロック解放

→ **全体で必ず同じ結果になります**

## 2相コミットが保証する性質

| 特性               | 2PCでの扱い  |
| ---------------- | -------- |
| 原子性(Atomicity)   | ◎ 保証     |
| 一貫性(Consistency) | DB側制約に依存 |
| 独立性(Isolation)   | ロックにより保証 |
| 永続性(Durability)  | ログにより保証  |

**中でも原子性を担保する仕組みです。**

## 障害発生時の挙動

### 参加者障害

* 再起動後、ログを参照
* コミット済／未確定を判断可能

### コーディネータ障害

* 参加者は 「コミットかアボートか分からない状態」 になる
* ロックを保持したまま待機

## 2相コミットの問題点

### ブロッキング問題(Blocking Problem)

* コーディネータ障害時
* 参加者が永久に待たされる可能性

### 性能低下

* 通信回数が多い
* ロック保持時間が長い

## 改良方式と関連知識

### 3相コミット(Three-Phase Commit)

* 2PCの欠点を軽減
* ただし実装が複雑

### 分散トランザクション代替手法

* Sagaパターン(補償トランザクション)
* Eventually Consistent な設計(NoSQL)

### CAP定理

分散データベースでは、透過性と合わせて以下の概念も重要です。

* 分散トランザクション
* 二相コミット
* 可用性と一貫性のトレードオフ
* CAP定理
