# バグ埋め込み法(エラーシーディング法)と式の導出(S, T, m, n)

## はじめに

2025年10月のプロジェクトマネージャ試験受験を終え、2026年春の情報処理安全確保支援士に向けて勉強中です。  
本記事を含めた各知識のインデックスや学習の道のりについては、「[情報処理安全確保支援士への道のり(随時更新中)](https://qiita.com/teppei19980914/items/6411cb70f2937cbefdcc)」をご参照ください。  
**本記事は学習した内容を記載しています。**  

## 該当問題

[情報セキュリティスペシャリスト平成23年秋期試験問題　午前Ⅱ 問22](https://www.sc-siken.com/kakomon/23_aki/am2_22.html)  

## バグ埋め込み法(Bug Seeding/Error Seeding)とは
**既知個数のバグ(種バグ)を意図的に埋め込み**、テストやレビューで見つかった「種バグの発見率」から、**埋め込み前から潜在していた未知バグの総数や残存数を推定する**考え方です。  

## 記号の定義

- **S**：埋め込んだバグ(種バグ)の総数  
- **m**：発見された種バグ数(S のうち見つかった数)  
- **T**：テスト開始前に潜在していたバグ総数(埋め込みバグを含まない「本来の潜在バグ数」)  
- **n**：発見された総バグ数(= 種バグ + 本来バグ の合計で見つかった数)

このとき、**発見された本来バグ数**は「n − m」です。  

## 成立のための前提(“式が成り立つ理由”)

バグ埋め込み法の推定は、典型的に次の仮定を置きます。

- **種バグと本来バグが、同程度の見つかりやすさ(検出確率)を持つ**
- テスト担当者は「どれが種バグか」を知らない(偏りが出ない)
- 種バグは本来バグと同様の分布/難易度で埋め込まれている

この仮定がないと、種バグの発見率から本来バグの発見率を外挿できません。  

## 求める式の導出(S, T, m, n の関係)

### 「発見率が同じ」という置き方

設問の仮定より、種バグと本来バグの**発見率(検出確率)が同じ**とみなします。

- 種バグの発見率：  
```
frac{m}{S}
```

- 本来バグの発見率(本来バグ T 個のうち n−m 個発見)：  
```
frac{n-m}{T}
```

仮定より両者は等しいので、

```
frac{m}{S}=frac{n-m}{T}
```

### 変形して関係式へ
両辺を交差乗算すると、

```
mT = S(n-m)
```

これが **S, T, m, n の関係式**です。  
さらに **T を解く**(潜在バグ総数の推定式)なら、

```
T=frac{S(n-m)}{m}
```

## 5. 試験での“読み替え”ポイント(よくあるひっかけ回避)

- **n は総発見バグ数**なので、そこには種バグ m が含まれる  
  → 本来バグの発見数は **n − m**
- 残存本来バグ数を問われたら  
```
T-(n-m)
```
- 「検出率」を先に作ると式を立てやすい  
    - 種：m/S  
    - 本来：(n−m)/T

## 限界/注意点(現実のテストではズレやすい)

バグ埋め込み法は、前提が崩れると推定が大きく外れます。  
代表例：  
- 種バグが簡単すぎる／難しすぎる(見つかりやすさが違う)
- 種バグの“埋め込み位置”が偏る(特定モジュールだけ等)
- テストが探索的で、発見確率が時間とともに変動する
- 種バグの存在がテストチームに知られ、行動が変化する

したがって、試験では「仮定の下での推定」を割り切って扱い、実務では補助的に用いる、という整理が安全です。  

## 7. 周辺知識(関連する“残存欠陥”推定/品質管理の話題)

- **欠陥除去率(DRE: Defect Removal Efficiency)**  
  工程内でどれだけ欠陥を除去できたかを測る指標(ただし真の総欠陥数が必要になる点が課題)
- **レビュー手法**(ウォークスルー/インスペクション)  
  テスト前工程で欠陥を落とすことで、後工程コストを下げるという品質原則
- **テストカバレッジ(網羅率)**  
  ステートメント/分岐/条件網羅など。  
  バグ埋め込み法は「カバレッジそのもの」ではなく「欠陥検出の進捗推定」という位置づけ。
